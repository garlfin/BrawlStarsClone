layout (binding = 0, rgb16f) restrict writeonly uniform imageCube outImage;
layout (binding = 1, rgb16f) restrict readonly uniform imageCube inImage;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

const float PI = 3.14159265359;

// http://alinloghin.com/articles/compute_ibl.html
// "Why write code when someone else smarter already wrote it?" -Someone Smart
vec3 globalToTexcoord(ivec3 cubeCoord, int size)
{
   
    
    vec2 texCoord = vec2(cubeCoord.xy) / vec2(size);
    texCoord = texCoord * 2.0 - 1.0; // -1..1
    
    switch(cubeCoord.z)
    {
        case 0: return vec3(1.0, -texCoord.yx); // posx
        case 1: return vec3(-1.0, -texCoord.y, texCoord.x); //negx
        case 2: return vec3(texCoord.x, 1.0, texCoord.y); // posy
        case 3: return vec3(texCoord.x, -1.0, -texCoord.y); //negy
        case 4: return vec3(texCoord.x, -texCoord.y, 1.0); // posz
        case 5: return vec3(-texCoord.xy, -1.0); // negz
        default: return vec3(0.0, 0.0, 0.0); // error
    }
}

ivec3 texCoordToCube(vec3 texCoord, vec2 cubemapSize)
{
    vec3 abst = abs(texCoord);
    texCoord /= max3(abst);

    float cubeFace;
    vec2 uvCoord;
    if (abst.x > abst.y && abst.x > abst.z)
    {
        // x major
        float negx = step(texCoord.x, 0.0);
        uvCoord = mix(-texCoord.zy, vec2(texCoord.z, -texCoord.y), negx);
        cubeFace = negx;
    }
    else if (abst.y > abst.z)
    {
        // y major
        float negy = step(texCoord.y, 0.0);
        uvCoord = mix(texCoord.xz, vec2(texCoord.x, -texCoord.z), negy);
        cubeFace = 2.0 + negy;
    }
    else
    {
        // z major
        float negz = step(texCoord.z, 0.0);
        uvCoord = mix(vec2(texCoord.x, -texCoord.y), -texCoord.xy, negz);
        cubeFace = 4.0 + negz;
    }
    uvCoord = (uvCoord + 1.0) * 0.5; // 0..1
    uvCoord = uvCoord * cubemapSize;
    uvCoord = clamp(uvCoord, vec2(0.0), cubemapSize - vec2(1.0));

    return ivec3(ivec2(uvCoord), int(cubeFace));
}

void main()
{
    vec3 dir = globalToTexcoord(ivec3(gl_GlobalInvocationID), imageSize(inImage).x);
    
    // tagent space from origin point
    vec3 normal = normalize(dir);
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(up, normal));
    up = cross(normal, right);

    vec3 sphereCoord = vec3(sinTheta * cosPhi,  sinTheta * sinPhi, cosTheta);
    // tangent space to world
    vec3 sampleVec = sphereCoord.x * right + sphereCoord.y * up + sphereCoord.z * normal;
    // world to cube coord
    ivec3 sampleCoord = texCoordToCube(sampleVec, cubemapSize);

    irradiance += imageLoad(environmentMap, sampleCoord).rgb * cosTheta * sinTheta;

    irradiance *= PI * invTotalSamples;
    imageStore(irradianceMap, cubeCoord, vec4(irradiance, 1.0));    
    
}